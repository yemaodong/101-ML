# 代码简介：10种具有变量筛选和预后模型构建的算法组合
# 

# 设置工作路径
rm(list=ls())
work.path <- "./101ML"; 
setwd(work.path) 

# 设置其他路径
code.path <- file.path(work.path, "Codes")
data.path <- file.path(work.path, "InputData")
res.path <- file.path(work.path, "Results")
fig.path <- file.path(work.path, "Figures")

# 如不存在这些路径则创建路径
if (!dir.exists(data.path)) dir.create(data.path)
if (!dir.exists(res.path)) dir.create(res.path)
if (!dir.exists(fig.path)) dir.create(fig.path)
if (!dir.exists(code.path)) dir.create(code.path)

#BiocManager::install("mixOmics")
#BiocManager::install("survcomp")
#devtools::install_github("binderh/CoxBoost")
#install.packages("randomForestSRC")
#install.packages("snowfall")
#install.packages("openxlsx")
#install.packages("seqinr")
#install.packages("plsRcox")
#install.packages("superpc")
#install.packages("gbm")
#install.packages("survivalsvm")
#install.packages("BART")
#install.packages("survivalsvm")


# 加载需要使用的R包
library(openxlsx)
library(seqinr)
library(plyr)
library(survival)
library(randomForestSRC)
library(glmnet)
library(plsRcox)
library(superpc)
library(gbm)
library(mixOmics)
library(survcomp)
library(CoxBoost)
library(survivalsvm)
library(BART)
library(snowfall)
library(ComplexHeatmap)
library(RColorBrewer)

# 加载模型训练以及模型评估的脚本
source(file.path(code.path, "ML.R"))

## Training Cohort ---------------------------------------------------------
# 训练集表达谱是行为基因（感兴趣的基因集），列为样本的表达矩阵（基因名与测试集保持相同类型，如同为SYMBOL或ENSEMBL等）
Train_expr <- read.table(file.path(data.path, "Training_expr.txt"), header = T, sep = " ", row.names = 1,check.names = F,stringsAsFactors = F)
Train_expr <- Train_expr[rowSums(Train_expr > 0) > ncol(Train_expr) * 0.1, ] # 剔除大量无表达的基因，以免建模过程报错
# 训练集生存数据是行为样本，列为结局信息的数据框
Train_surv <- read.table(file.path(data.path, "Training_surv.txt"), header = T, sep = " ", row.names = 1,check.names = F,stringsAsFactors = F)
Train_surv <- Train_surv[Train_surv$futime > 0, c("fustat", "futime")] # 提取OS大于0的样本
comsam <- intersect(rownames(Train_surv), colnames(Train_expr))
Train_expr <- Train_expr[,comsam]; Train_surv <- Train_surv[comsam,,drop = F]

## Validation Cohort -------------------------------------------------------
# 测试集表达谱是行为基因（感兴趣的基因集），列为样本的表达矩阵（基因名与训练集保持相同类型，如同为SYMBOL或ENSEMBL等）
Test_expr <- read.table(file.path(data.path, "Testing_expr.txt"), header = T, sep = " ", row.names = 1,check.names = F,stringsAsFactors = F)
# 测试集生存数据是行为样本，列为结局信息的数据框
Test_surv <- read.table(file.path(data.path, "Testing_surv.txt"), header = T, sep = " ", row.names = 1,check.names = F,stringsAsFactors = F)
Test_surv <- Test_surv[Test_surv$futime > 0, c("Coho","fustat", "futime")] # 提取OS大于0的样本
comsam <- intersect(rownames(Test_surv), colnames(Test_expr))
Test_expr <- Test_expr[,comsam]; Test_surv <- Test_surv[comsam,,drop = F]

# 提取相同基因
comgene <- intersect(rownames(Train_expr),rownames(Test_expr))
Train_expr <- t(Train_expr[comgene,]) # 输入模型的表达谱行为样本，列为基因
Test_expr <- t(Test_expr[comgene,]) # 输入模型的表达谱行为样本，列为基因

# Model training and validation -------------------------------------------

## method list --------------------------------------------------------
# 此处记录需要运行的模型，格式为：算法1名称[算法参数]+算法2名称[算法参数]
# 目前仅有StepCox和RunEnet支持输入算法参数
methods <- read.xlsx(file.path(code.path, "models_name.xlsx"), startRow = 2)
methods <- methods$Model
methods <- gsub("-| ", "", methods)
head(methods)


## Train the model --------------------------------------------------------
model <- list()
set.seed(seed = 123)
for (method in methods){
  cat(match(method, methods), ":", method, "\n")
  method_name = method # 本轮算法名称
  method <- strsplit(method, "\\+")[[1]] # 各步骤算法名称
  
  Variable = colnames(Train_expr) # 最后用于构建模型的变量
  for (i in 1:length(method)){
    if (i < length(method)){
      selected.var <- RunML(method = method[i], # 机器学习方法
                            Train_expr = Train_expr, # 训练集有潜在预测价值的变量
                            Train_surv = Train_surv, # 训练集生存数据
                            mode = "Variable",       # 运行模式，Variable(筛选变量)和Model(获取模型)
                            timeVar = "futime", statusVar = "fustat") # 用于训练的生存变量，必须出现在Train_surv中
      if (length(selected.var) > 5) Variable <- intersect(Variable, selected.var)
    } else {
      model[[method_name]] <- RunML(method = method[i],
                                    Train_expr = Train_expr[, Variable],
                                    Train_surv = Train_surv,
                                    mode = "Model",
                                    timeVar = "futime", statusVar = "fustat")
    }
  }
}
saveRDS(model, file.path(res.path, "model.rds"))

## Evaluate the model -----------------------------------------------------

# 读取已报错的模型列表
model <- readRDS(file.path(res.path, "model.rds"))
summary(Train_expr)
summary(Test_expr)



# 对各模型计算C-index
#is.finite(Test_expr)
#Test_expr[!is.finite(Test_expr)] <- NA
Cindexlist <- list()
for (method in methods){
  Cindexlist[[method]] <- RunEval(fit = model[[method]], # 预后模型
                                  Test_expr = Test_expr, # 测试集预后变量，应当包含训练集中所有的变量，否则会报错
                                  Test_surv = Test_surv, # 训练集生存数据，应当包含训练集中所有的变量，否则会报错
                                  Train_expr = Train_expr, # 若需要同时评估训练集，则给出训练集表达谱，否则置NULL
                                  Train_surv = Train_surv, # 若需要同时评估训练集，则给出训练集生存数据，否则置NULL
                                  Train_name = "TCGA", # 若需要同时评估训练集，可给出训练集的标签，否则按“Training”处理
                                  cohortVar = "Coho", # 重要：用于指定队列的变量，该列必须存在且指定[默认为“Cohort”]，否则会报错
                                  timeVar = "futime", # 用于评估的生存时间，必须出现在Test_surv中
                                  statusVar = "fustat") # 用于评估的生存状态，必须出现在Test_surv中
}
Cindex_mat <- do.call(rbind, Cindexlist)
write.table(Cindex_mat, file.path(res.path, "Cindex_mat.txt"),
            sep = "\t", row.names = T, col.names = T, quote = F)

# Plot --------------------------------------------------------------------

Cindex_mat <- read.table(file.path(res.path, "Cindex_mat.txt"),sep = "\t", row.names = 1, header = T,check.names = F,stringsAsFactors = F)
avg_Cindex <- apply(Cindex_mat, 1, mean)           # 计算每种算法在所有队列中平均C-index
avg_Cindex <- sort(avg_Cindex, decreasing = T)     # 对各算法C-index由高到低排序
Cindex_mat <- Cindex_mat[names(avg_Cindex), ]      # 对C-index矩阵排序

avg_Cindex <- as.numeric(format(avg_Cindex, digits = 3, nsmall = 3)) # 保留三位小数
row_ha = rowAnnotation(bar = anno_barplot(avg_Cindex, bar_width = 0.8, border = FALSE,
                                          gp = gpar(fill = "steelblue", col = NA),
                                          add_numbers = T, numbers_offset = unit(-10, "mm"),
                                          axis_param = list("labels_rot" = 0),
                                          numbers_gp = gpar(fontsize = 9, col = "white"),
                                          width = unit(3, "cm")),
                       show_annotation_name = F)

#CohortCol <- brewer.pal(n = ncol(Cindex_mat), name = "Paired") # 设置队列颜色

CohortCol <- c("steelblue", "firebrick") # 你可以替换这两种颜色为你喜欢的颜色

names(CohortCol) <- colnames(Cindex_mat)
col_ha = columnAnnotation("Cohort" = colnames(Cindex_mat),
                          col = list("Cohort" = CohortCol),
                          show_annotation_name = F)


cellwidth = 1
cellheight = 0.5
hm <- Heatmap(as.matrix(Cindex_mat), name = "C-index",
              right_annotation = row_ha, 
              top_annotation = col_ha,
              # col = c("#1CB8B2", "#FFFFFF", "#EEB849"), # 黄绿配色
              col = c("#4195C1", "#FFFFFF", "#CB5746"), # 红蓝配色
              rect_gp = gpar(col = "black", lwd = 1), # 边框设置为黑色
              cluster_columns = FALSE, cluster_rows = FALSE, # 不进行聚类，无意义
              show_column_names = FALSE, 
              show_row_names = TRUE,
              row_names_side = "left",
              width = unit(cellwidth * ncol(Cindex_mat) + 2, "cm"),
              height = unit(cellheight * nrow(Cindex_mat), "cm"),
              column_split = factor(colnames(Cindex_mat), levels = colnames(Cindex_mat)), 
              column_title = NULL,
              cell_fun = function(j, i, x, y, w, h, col) { # add text to each grid
                grid.text(label = format(Cindex_mat[i, j], digits = 3, nsmall = 3),
                          x, y, gp = gpar(fontsize = 10))
              }
)

#pdf(file.path(fig.path, "Cindex.pdf"), width = cellwidth * ncol(Cindex_mat) + 3, height = cellheight * nrow(Cindex_mat) * 0.45)
pdf(file.path(fig.path, "Cindex2.pdf"), width = (cellwidth * ncol(Cindex_mat) + 3) * 2, height = cellheight * nrow(Cindex_mat) * 0.45)

draw(hm)
invisible(dev.off())

#筛选最优的基因
for (method in methods){
  
  if (method == "StepCox[both]+SuperPC"){
    data1=data.frame(model[[method]][["subFeature"]])
    write.table(data1, file = "selected_genes.txt", row.names = FALSE, col.names = FALSE)
  } 
}

